import os
import logging
import sqlite3
import re
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from contextlib import contextmanager
from dotenv import load_dotenv

load_dotenv()
logging.basicConfig(level=logging.INFO)

bot = Bot(token="7799348568:AAEFkoTyYPDxhR1rSzlposQMkr5PbjJEL7U")
dp = Dispatcher()

class DatabaseManager:
    def __init__(self, db_path='students.db'):
        self.db_path = db_path
        self._initialize_database()

    @contextmanager
    def _get_cursor(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            yield cursor
        finally:
            conn.commit()
            conn.close()

    def _initialize_database(self):
        with self._get_cursor() as cursor:
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS groups (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    course INTEGER NOT NULL
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    telegram_profile TEXT,
                    phone_number TEXT,
                    group_id INTEGER,
                    FOREIGN KEY (group_id) REFERENCES groups(id)
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS contacts (
                    user_id INTEGER PRIMARY KEY,
                    phone_number TEXT NOT NULL
                )
            ''')

    def add_group(self, name, course):
        try:
            with self._get_cursor() as cursor:
                cursor.execute('INSERT INTO groups (name, course) VALUES (?, ?)', (name, course))
                logging.info(f"Group '{name}' added successfully.")
                return True, f"âœ… Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° '{name}' ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ½Ğ° ĞºÑƒÑ€Ñ {course}!"
        except sqlite3.IntegrityError:
            logging.warning(f"Group '{name}' already exists.")
            return False, f"ğŸš« Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° '{name}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚."
        except Exception as e:
            logging.error(f"Error adding group '{name}': {e}")
            return False, f"ğŸš« ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ '{name}': {e}"

    def group_exists(self, name, course):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM groups WHERE name=? AND course=?', (name, course))
            return cursor.fetchone() is not None

    def get_all_groups(self):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM groups')
            return cursor.fetchall()

    def get_groups_by_course(self, course):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM groups WHERE course=?', (course,))
            return cursor.fetchall()

    def delete_group(self, group_id):
        with self._get_cursor() as cursor:
            cursor.execute('DELETE FROM groups WHERE id=?', (group_id,))

    def add_student(self, name, telegram_profile=None, phone_number=None, group_id=None):
        with self._get_cursor() as cursor:
            cursor.execute('''
                INSERT INTO students (name, telegram_profile, phone_number, group_id)
                VALUES (?, ?, ?, ?)
            ''', (name, telegram_profile, phone_number, group_id))

    def student_exists(self, name, telegram_profile):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM students WHERE name=? OR telegram_profile=?', (name, telegram_profile))
            return cursor.fetchone() is not None

    def get_all_students(self):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM students')
            return cursor.fetchall()

    def get_students_by_group(self, group_id):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM students WHERE group_id=?', (group_id,))
            return cursor.fetchall()

    def delete_student(self, student_id):
        with self._get_cursor() as cursor:
            cursor.execute('DELETE FROM students WHERE id=?', (student_id,))

    def delete_student_by_telegram(self, telegram_profile):
        with self._get_cursor() as cursor:
            cursor.execute('DELETE FROM students WHERE telegram_profile=?', (telegram_profile,))

    def has_contact(self, user_id):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT * FROM contacts WHERE user_id=?', (user_id,))
            return cursor.fetchone() is not None

    def save_contact(self, user_id, phone_number):
        with self._get_cursor() as cursor:
            cursor.execute('INSERT OR IGNORE INTO contacts (user_id, phone_number) VALUES (?, ?)', (user_id, phone_number))

    def get_contact(self, user_id):
        with self._get_cursor() as cursor:
            cursor.execute('SELECT phone_number FROM contacts WHERE user_id=?', (user_id,))
            result = cursor.fetchone()
            return result[0] if result else None

    def get_student_group(self, telegram_profile):
        with self._get_cursor() as cursor:
            cursor.execute('''
                SELECT g.name, g.course 
                FROM students s 
                JOIN groups g ON s.group_id = g.id 
                WHERE s.telegram_profile = ?
            ''', (telegram_profile,))
            result = cursor.fetchone()
            return result if result else None

db = DatabaseManager()

class Form(StatesGroup):
    waiting_for_group_name = State()
    waiting_for_group_course = State()
    waiting_for_group_selection = State()
    waiting_for_group = State()
    waiting_for_name = State()

class AdminPanel(StatesGroup):
    managing_users = State()
    managing_groups = State()
    selecting_course_for_users = State()
    selecting_group_for_users = State()

class ViewStudents(StatesGroup):
    selecting_course = State()
    selecting_group = State()

def main_menu_keyboard(registered=False):
    if registered:
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")],
                [KeyboardButton(text="ğŸ‘¥ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ")],
                [KeyboardButton(text="ğŸ”„ Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")],
                [KeyboardButton(text="ğŸ’¸ Ğ”Ğ¾Ğ½Ğ°Ñ‚"), KeyboardButton(text="âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ")]
            ],
            resize_keyboard=True
        )
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")],
            [KeyboardButton(text="ğŸ‘¥ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ")],
            [KeyboardButton(text="ğŸ’¸ Ğ”Ğ¾Ğ½Ğ°Ñ‚"), KeyboardButton(text="âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ")]
        ],
        resize_keyboard=True
    )

def admin_panel_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="ğŸ‘¤ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸")],
            [KeyboardButton(text="ğŸ“š Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°Ğ¼Ğ¸")],
            [KeyboardButton(text="â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")],
            [KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]
        ],
        resize_keyboard=True
    )

def course_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="1 ĞºÑƒÑ€Ñ")],
            [KeyboardButton(text="2 ĞºÑƒÑ€Ñ")],
            [KeyboardButton(text="3 ĞºÑƒÑ€Ñ")],
            [KeyboardButton(text="4 ĞºÑƒÑ€Ñ")],
            [KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]
        ],
        resize_keyboard=True
    )

def validate_and_format_phone_number(phone_number: str) -> str | None:
    cleaned_number = re.sub(r"[^0-9]", "", phone_number)
    if len(cleaned_number) == 11:
        if cleaned_number.startswith("8"):
            return "+7" + cleaned_number[1:]
        elif cleaned_number.startswith("7"):
            return "+" + cleaned_number
    elif len(cleaned_number) == 10:
        return "+7" + cleaned_number
    return None

@dp.message(Command("start"))
async def start(message: types.Message):
    if not db.has_contact(message.from_user.id):
        keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="ğŸ“² ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚", request_contact=True)]],
            resize_keyboard=True
        )
        await message.answer("ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.", reply_markup=keyboard)
    else:
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        group_info = db.get_student_group(telegram_profile)
        if group_info:
            group_name, course = group_info
            welcome_message = f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ’Ñ‹ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ '{group_name}' (ĞšÑƒÑ€Ñ {course}).\nĞ­Ñ‚Ğ¾ Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ² ÑƒÑ‡ĞµĞ±Ğ½ÑƒÑ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ."
            keyboard = main_menu_keyboard(registered=True)
        else:
            welcome_message = "ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ½Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ.\nĞ­Ñ‚Ğ¾ Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ² ÑƒÑ‡ĞµĞ±Ğ½ÑƒÑ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ."
            keyboard = main_menu_keyboard(registered=False)
        await message.answer(welcome_message, reply_markup=keyboard)

@dp.message(F.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")
async def return_to_main_menu(message: types.Message, state: FSMContext):
    await state.clear()
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    group_info = db.get_student_group(telegram_profile)
    if group_info:
        group_name, course = group_info
        response = f"ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.\nĞ’Ñ‹ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ '{group_name}' (ĞšÑƒÑ€Ñ {course})."
        keyboard = main_menu_keyboard(registered=True)
    else:
        response = "ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.\nĞ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ½Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ."
        keyboard = main_menu_keyboard(registered=False)
    await message.answer(response, reply_markup=keyboard)

@dp.message(F.contact)
async def process_contact(message: types.Message):
    if message.contact and message.contact.phone_number:
        db.save_contact(message.from_user.id, message.contact.phone_number)
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        group_info = db.get_student_group(telegram_profile)
        keyboard = main_menu_keyboard(registered=bool(group_info))
        await message.answer("âœ… Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚!", reply_markup=keyboard)

ADMIN_ID = 6072376664

@dp.message(Command("admin"))
async def admin_panel(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        await message.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", reply_markup=main_menu_keyboard())
        return
    await message.answer("ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°!", reply_markup=admin_panel_keyboard())

@dp.message(F.text == "â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")
async def add_group_start(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", reply_markup=main_menu_keyboard())
        return
    await message.answer("ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹:", reply_markup=ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]],
        resize_keyboard=True
    ))
    await state.set_state(Form.waiting_for_group_name)

@dp.message(Form.waiting_for_group_name)
async def process_group_name(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=main_menu_keyboard())
        return
    group_name = message.text.strip()
    if not group_name or len(group_name) > 50:
        await message.answer("ğŸš« ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼ Ğ¸Ğ»Ğ¸ Ğ´Ğ»Ğ¸Ğ½Ğ½ĞµĞµ 50 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ².")
        return
    await state.update_data({"group_name": group_name})
    await message.answer("ğŸ“š Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ ĞºÑƒÑ€ÑĞ° (1-4):", reply_markup=ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]],
        resize_keyboard=True
    ))
    await state.set_state(Form.waiting_for_group_course)

@dp.message(Form.waiting_for_group_course)
async def process_group_course(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=main_menu_keyboard())
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        await message.answer("ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹:", reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]],
            resize_keyboard=True
        ))
        await state.set_state(Form.waiting_for_group_name)
        return
    try:
        course = int(message.text)
        if course < 1 or course > 4:
            raise ValueError
    except ValueError:
        await message.answer("ğŸš« ĞĞ¾Ğ¼ĞµÑ€ ĞºÑƒÑ€ÑĞ° Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ¼ Ğ¾Ñ‚ 1 Ğ´Ğ¾ 4.")
        return
    data = await state.get_data()
    group_name = data.get("group_name")
    if db.group_exists(group_name, course):
        await message.answer(f"ğŸš« Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° '{group_name}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ½Ğ° ĞºÑƒÑ€ÑĞµ {course}.", reply_markup=main_menu_keyboard())
    else:
        success, message_text = db.add_group(group_name, course)
        await message.answer(message_text, reply_markup=admin_panel_keyboard())
    await state.clear()

@dp.message(F.text == "ğŸ“š Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°Ğ¼Ğ¸")
async def manage_groups(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        await message.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", reply_markup=main_menu_keyboard())
        return
    groups = db.get_all_groups()
    if not groups:
        await message.answer("ğŸ“­ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ³Ñ€ÑƒĞ¿Ğ¿ Ğ¿ÑƒÑÑ‚.", reply_markup=admin_panel_keyboard())
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    for group in groups:
        keyboard.inline_keyboard.append(
            [InlineKeyboardButton(text=f"âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ: {group[1]} (ĞšÑƒÑ€Ñ {group[2]})", callback_data=f"confirm_delete_group_{group[0]}")]
        )
    await message.answer("ğŸ“‹ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ³Ñ€ÑƒĞ¿Ğ¿:", reply_markup=keyboard)

@dp.message(F.text == "ğŸ‘¤ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸")
async def manage_users(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", reply_markup=main_menu_keyboard())
        return
    await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸:", reply_markup=course_keyboard())
    await state.set_state(AdminPanel.selecting_course_for_users)

@dp.message(AdminPanel.selecting_course_for_users)
async def process_course_selection_for_users(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=main_menu_keyboard())
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        await message.answer("ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°!", reply_markup=admin_panel_keyboard())
        await state.clear()
        return
    try:
        course = int(message.text.split()[0])
    except (ValueError, IndexError):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ ĞºÑƒÑ€ÑĞ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    groups = db.get_groups_by_course(course)
    if not groups:
        await message.answer(f"ğŸš« ĞĞ° ĞºÑƒÑ€ÑĞµ {course} Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ³Ñ€ÑƒĞ¿Ğ¿.", reply_markup=admin_panel_keyboard())
        await state.clear()
        return
    await state.update_data({"course": course})
    group_buttons = [[KeyboardButton(text=f"ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° {group[1]}")] for group in groups]
    group_buttons.append([KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")])
    group_keyboard = ReplyKeyboardMarkup(keyboard=group_buttons, resize_keyboard=True)
    await message.answer(f"ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ½Ğ° ĞºÑƒÑ€ÑĞµ {course}:", reply_markup=group_keyboard)
    await state.set_state(AdminPanel.selecting_group_for_users)

@dp.message(AdminPanel.selecting_group_for_users)
async def process_group_selection_for_users(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=main_menu_keyboard())
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸:", reply_markup=course_keyboard())
        await state.set_state(AdminPanel.selecting_course_for_users)
        return
    if not message.text.startswith("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° "):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    selected_group = message.text.replace("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ", "").strip()
    data = await state.get_data()
    course = data.get("course")
    groups = db.get_groups_by_course(course)
    group_id = next((group[0] for group in groups if group[1] == selected_group), None)
    if group_id is None:
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    students = db.get_students_by_group(group_id)
    if not students:
        await message.answer(f"ğŸ“­ Ğ’ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ '{selected_group}' Ğ½ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.", reply_markup=admin_panel_keyboard())
        await state.clear()
        return
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    for student in students:
        keyboard.inline_keyboard.append(
            [InlineKeyboardButton(text=f"âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ: {student[1]}", callback_data=f"confirm_delete_student_{student[0]}")]
        )
    await message.answer(f"ğŸ“‹ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¸Ğ· Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ '{selected_group}':", reply_markup=keyboard)
    await state.clear()

@dp.callback_query(F.data.startswith("confirm_delete_"))
async def confirm_delete(callback: types.CallbackQuery):
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", show_alert=True)
        return
    data = callback.data
    if data.startswith("confirm_delete_group_"):
        group_id = int(data.split("_")[3])
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"delete_group_{group_id}")],
                [InlineKeyboardButton(text="âŒ ĞĞµÑ‚, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_delete")]
            ]
        )
        await callback.message.edit_text(f"â“ Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ñ ID {group_id}?", reply_markup=keyboard)
    elif data.startswith("confirm_delete_student_"):
        student_id = int(data.split("_")[3])
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="âœ… Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"delete_student_{student_id}")],
                [InlineKeyboardButton(text="âŒ ĞĞµÑ‚, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ°", callback_data="cancel_delete")]
            ]
        )
        await callback.message.edit_text(f"â“ Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ ID {student_id}?", reply_markup=keyboard)

@dp.callback_query()
async def process_callback(callback: types.CallbackQuery):
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("ğŸš« Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹.", show_alert=True)
        return
    data = callback.data
    if data.startswith("delete_group_"):
        group_id = int(data.split("_")[2])
        db.delete_group(group_id)
        await callback.answer(f"âœ… Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ñ ID {group_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°.", show_alert=True)
        await callback.message.edit_text("âœ… Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°.")
    elif data.startswith("delete_student_"):
        student_id = int(data.split("_")[2])
        db.delete_student(student_id)
        await callback.answer(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ ID {student_id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½.", show_alert=True)
        await callback.message.edit_text("âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ´Ğ°Ğ»ĞµĞ½.")
    elif data == "cancel_delete":
        await callback.message.edit_text("ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°!", reply_markup=admin_panel_keyboard())
    await callback.answer()

@dp.message(F.text == "ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")
async def register(message: types.Message, state: FSMContext):
    if not db.has_contact(message.from_user.id):
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚. Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        return
    await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ:", reply_markup=course_keyboard())
    await state.set_state(Form.waiting_for_group_selection)

@dp.message(F.text == "ğŸ”„ Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ")
async def change_group(message: types.Message, state: FSMContext):
    if not db.has_contact(message.from_user.id):
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚. Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        return
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    group_info = db.get_student_group(telegram_profile)
    if not group_info:
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ½Ğ¸ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ 'ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ' Ğ´Ğ»Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸.", reply_markup=main_menu_keyboard(registered=False))
        return
    db.delete_student_by_telegram(telegram_profile)
    await message.answer("âœ… Ğ’Ğ°ÑˆĞ° Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ:", reply_markup=course_keyboard())
    await state.set_state(Form.waiting_for_group_selection)

@dp.message(Form.waiting_for_group_selection)
async def process_course_selection(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        await state.clear()
        return
    try:
        course = int(message.text.split()[0])
    except (ValueError, IndexError):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ ĞºÑƒÑ€ÑĞ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    groups = db.get_groups_by_course(course)
    if not groups:
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        await message.answer(f"ğŸš« ĞĞ° ĞºÑƒÑ€ÑĞµ {course} Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ³Ñ€ÑƒĞ¿Ğ¿.", reply_markup=main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile))))
        await state.clear()
        return
    await state.update_data({"course": course})
    group_buttons = [[KeyboardButton(text=f"ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° {group[1]}")] for group in groups]
    group_buttons.append([KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")])
    group_keyboard = ReplyKeyboardMarkup(keyboard=group_buttons, resize_keyboard=True)
    await message.answer(f"ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ½Ğ° ĞºÑƒÑ€ÑĞµ {course}:", reply_markup=group_keyboard)
    await state.set_state(Form.waiting_for_group)

@dp.message(Form.waiting_for_group)
async def process_group_selection(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ:", reply_markup=course_keyboard())
        await state.set_state(Form.waiting_for_group_selection)
        return
    if not message.text.startswith("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° "):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    selected_group = message.text.replace("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ", "").strip()
    data = await state.get_data()
    course = data.get("course")
    groups = db.get_groups_by_course(course)
    group_id = next((group[0] for group in groups if group[1] == selected_group), None)
    if group_id is None:
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    await state.update_data({"group_id": group_id})
    await message.answer("ğŸ‘¤ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¼Ğ¸Ğ»Ğ¸Ñ Ğ¸ Ğ¸Ğ¼Ñ:", reply_markup=ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")]],
        resize_keyboard=True
    ))
    await state.set_state(Form.waiting_for_name)

@dp.message(Form.waiting_for_name)
async def process_name(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        data = await state.get_data()
        course = data.get("course")
        groups = db.get_groups_by_course(course)
        group_buttons = [[KeyboardButton(text=f"ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° {group[1]}")] for group in groups]
        group_buttons.append([KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")])
        group_keyboard = ReplyKeyboardMarkup(keyboard=group_buttons, resize_keyboard=True)
        await message.answer(f"ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ½Ğ° ĞºÑƒÑ€ÑĞµ {course}:", reply_markup=group_keyboard)
        await state.set_state(Form.waiting_for_group)
        return
    name = message.text.strip()
    if not name:
        await message.answer("ğŸš« Ğ˜Ğ¼Ñ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¼Ğ¸Ğ»Ğ¸Ñ Ğ¸ Ğ¸Ğ¼Ñ:")
        return
    data = await state.get_data()
    group_id = data.get("group_id")
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    phone_number = db.get_contact(message.from_user.id)
    if not phone_number:
        await message.answer("ğŸš« ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ñˆ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        await state.clear()
        return
    if db.student_exists(name, telegram_profile):
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer(f"ğŸš« Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ '{name}' Ğ¸Ğ»Ğ¸ Telegram-Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ĞµĞ¼ '{telegram_profile}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚.", reply_markup=keyboard)
    else:
        db.add_student(name, telegram_profile, phone_number, group_id)
        await message.answer("âœ… Ğ’Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ!", reply_markup=main_menu_keyboard(registered=True))
    await state.clear()

@dp.message(F.text == "ğŸ‘¥ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ")
async def view_students(message: types.Message, state: FSMContext):
    if not db.has_contact(message.from_user.id):
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚. Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        return
    await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ÑĞ¿Ğ¸ÑĞºĞ° ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ:", reply_markup=course_keyboard())
    await state.set_state(ViewStudents.selecting_course)

@dp.message(ViewStudents.selecting_course)
async def process_course_selection_for_view(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        await state.clear()
        return
    try:
        course = int(message.text.split()[0])
    except (ValueError, IndexError):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ ĞºÑƒÑ€ÑĞ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    groups = db.get_groups_by_course(course)
    if not groups:
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        await message.answer(f"ğŸš« ĞĞ° ĞºÑƒÑ€ÑĞµ {course} Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ³Ñ€ÑƒĞ¿Ğ¿.", reply_markup=main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile))))
        await state.clear()
        return
    await state.update_data({"course": course})
    group_buttons = [[KeyboardButton(text=f"ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° {group[1]}")] for group in groups]
    group_buttons.append([KeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´"), KeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ")])
    group_keyboard = ReplyKeyboardMarkup(keyboard=group_buttons, resize_keyboard=True)
    await message.answer(f"ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ½Ğ° ĞºÑƒÑ€ÑĞµ {course}:", reply_markup=group_keyboard)
    await state.set_state(ViewStudents.selecting_group)

@dp.message(ViewStudents.selecting_group)
async def process_group_selection_for_view(message: types.Message, state: FSMContext):
    if message.text == "ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ":
        await state.clear()
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
        await message.answer("ğŸ  Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.", reply_markup=keyboard)
        return
    if message.text == "ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´":
        await message.answer("ğŸ“š Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºÑƒÑ€Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ÑĞ¿Ğ¸ÑĞºĞ° ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ:", reply_markup=course_keyboard())
        await state.set_state(ViewStudents.selecting_course)
        return
    if not message.text.startswith("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° "):
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    selected_group = message.text.replace("ğŸ“š Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ", "").strip()
    data = await state.get_data()
    course = data.get("course")
    groups = db.get_groups_by_course(course)
    group_id = next((group[0] for group in groups if group[1] == selected_group), None)
    if group_id is None:
        await message.answer("ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:")
        return
    students = db.get_students_by_group(group_id)
    if not students:
        telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
        await message.answer(f"ğŸ“­ Ğ’ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ '{selected_group}' Ğ½ĞµÑ‚ ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ.", reply_markup=main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile))))
        await state.clear()
        return
    response = f"ğŸ“‹ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°Ñ‰Ğ¸Ñ…ÑÑ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ '{selected_group}' (ĞšÑƒÑ€Ñ {course}):\n\n"
    for student in students:
        response += (
            f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {student[1]}\n"
            f"ğŸ“± Telegram: {student[2]}\n"
            f"ğŸ“ Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {student[3]}\n\n"
        )
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    await message.answer(response, reply_markup=main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile))))
    await state.clear()

@dp.message(F.text == "âŒ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ")
async def delete_profile(message: types.Message):
    if not db.has_contact(message.from_user.id):
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚. Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        return
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    db.delete_student_by_telegram(telegram_profile)
    await message.answer("âœ… Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½.", reply_markup=main_menu_keyboard(registered=False))

@dp.message(F.text == "ğŸ’¸ Ğ”Ğ¾Ğ½Ğ°Ñ‚")
async def donate(message: types.Message):
    if not db.has_contact(message.from_user.id):
        await message.answer("ğŸš« Ğ’Ñ‹ Ğ½Ğµ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚. Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚.")
        return
    donate_button = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="ğŸ’¸ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚", url="https://yoomoney.ru/to/4100118763269949")]
        ]
    )
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    await message.answer("ğŸ’– Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°!", reply_markup=donate_button)

@dp.message()
async def handle_unknown_message(message: types.Message):
    telegram_profile = f"@{message.from_user.username}" if message.from_user.username else None
    keyboard = main_menu_keyboard(registered=bool(db.get_student_group(telegram_profile)))
    await message.answer(
        "ğŸš« Ğ’Ñ‹ Ğ²Ğ²ĞµĞ»Ğ¸ Ğ½ĞµĞ²ĞµÑ€Ğ½ÑƒÑ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ° Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=keyboard
    )

if __name__ == '__main__':
    dp.run_polling(bot)
